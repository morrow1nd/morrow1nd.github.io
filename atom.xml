<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>morrow1nd</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://morrow1nd.github.io/"/>
  <updated>2017-02-14T14:26:27.183Z</updated>
  <id>https://morrow1nd.github.io/</id>
  
  <author>
    <name>morrow1nd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp资源管理--智能指针、引用计数、weak_ptr</title>
    <link href="https://morrow1nd.github.io/2017/02/14/cpp%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E3%80%81weak-ptr/"/>
    <id>https://morrow1nd.github.io/2017/02/14/cpp资源管理-智能指针、引用计数、weak-ptr/</id>
    <published>2017-02-14T06:20:01.000Z</published>
    <updated>2017-02-14T14:26:27.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 本文面向c++初学者，讲述现代c++语言中的资源管理，包含但不限于：资源获取即初始化(RAII), 智能指针，引用计数，weak_ptr的由来，垃圾回收机制。帮助c++初学者了解c++与c在资源管理上的不同，理解c++中的struct与c中的不同之处。并与具有完备的垃圾回收机制的语言进行对比。</p>
<a id="more"></a>
<h2 id="c-中的struct-class"><a href="#c-中的struct-class" class="headerlink" title="c++中的struct/class"></a>c++中的struct/class</h2><p> 正确且全面的掌握class是理解和使用c++的基础。本文只关注class提供的构造函数、析构函数，其他内容请参阅 <a href="https://www.amazon.cn/dp/B004G72P24" target="_blank" rel="external">Effective C++</a>。</p>
<p> c语言提供了struct，但c++中的struct和它不同。c++中的struct是所有成员默认都是<code>public</code>的class. c++中的对象在被构造时，相应的构造函数会被调用，对象被释放时，相应的析构函数会被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Foo &#123;</div><div class="line">    ... </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        Foo foo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 当运行到这里时：</span></div><div class="line">    <span class="comment">// 在c++中，Foo的析构函数会被调用。</span></div><div class="line">    <span class="comment">// 在c中，当前作用域中无foo。</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上面的代码在c和c++中都不会有内存泄漏。但c++提供了更多的控制能力。对于任意一个对象（存储在堆中或栈中），该对象在被释放时（显示的使用delete或局部变量隐式的释放），其析构函数必然会被调用。这意味着我们可以利用局部变量的隐式释放来管理资源。具体来说，可以在析构函数中添加一些资源管理的代码，这些代码会在对象析构时被调用。同时，如果将资源获取的过程放在对象的构造函数中，使得实例化一个对象就是获取了一定的资源。这样的资源管理方式就是<strong>资源获取即初始化</strong>(Resource Acquisition Is Initialization - RAII)。</p>
<p> 运用RAII可以更好的管理资源，减少代码重复，提高可读性，预防bug的出现。下面给出实际的一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">syncFromFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filepath)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获取资源</span></div><div class="line">    FILE* fp = fopen(filepath.c_str(), <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span>(!fp)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(handle(file.fp) == FAIL)&#123;</div><div class="line">        fclose(fp);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(handle_second_step(file.fp) == FAIL)&#123;</div><div class="line">        fclose(fp);</div><div class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(handle_third_step(file.fp) == FAIL)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// 忘记添加释放资源的代码了。当资源更多，函数更复杂，团队多人协作时，这种情况很可能发生。</span></div><div class="line">    &#125;</div><div class="line">    fclose(fp);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 下面是运用RAII的代码。RAII不仅仅可以用来管理内存，还可以用来管理锁、文件描述符、socket连接等等。这也是为什么本文的标题是资源管理而不是内存管理的原因。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> FileHandler </div><div class="line">&#123;</div><div class="line">    FILE* fp;</div><div class="line"></div><div class="line">    FileHandler(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filepath)</div><div class="line">    &#123;</div><div class="line">        fp = fopen(filepath.c_str(), <span class="string">"r"</span>); </div><div class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ~FileHandler()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(fp) fclose(fp);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 代码非常简洁明了</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">syncFromFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filepath)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">FileHandler <span class="title">file</span><span class="params">(filepath)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(handle(file.fp) == FAIL)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(handle_second_step(file.fp) == FAIL)</div><div class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</div><div class="line">    <span class="keyword">if</span>(handle_third_step(file.fp) == FAIL)</div><div class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="c-智能指针"><a href="#c-智能指针" class="headerlink" title="c++智能指针"></a>c++智能指针</h2><h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><p> 首先，我想说的是智能指针并不智能，不知道这是怎么取名的 :(。我们先来看看早期c++提供的智能指针 <code>auto_ptr</code>。早期c++只有这一个智能指针，功能是在被构造时传入一个指针，并且在析构时自动<code>delete</code>掉这个指针。下面是一个使用例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span> <span class="comment">// auto_ptr needs this</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Foo &#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    Foo(<span class="keyword">int</span> val) : val(val) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Foo* raw_pointer)</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">auto_ptr</span>&lt;Foo&gt; fooh(<span class="keyword">new</span> Foo(<span class="number">123</span>));</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; fooh-&gt;val &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 就像使用一个原生指针一样: foop-&gt;val</span></div><div class="line">    fooh-&gt;val = <span class="number">321</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; fooh-&gt;val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    Foo* foop = fooh.get(); <span class="comment">// 获得raw pointer</span></div><div class="line">    func(foop);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> auto_ptr现在已被抛弃，不推荐使用，请使用它的替代品<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="external">unique_ptr</a>。本文不深入介绍c++智能指针的所有方面，请参考<a href="http://www.cplusplus.com/reference/memory/" target="_blank" rel="external">cplusplus website</a>和<a href="http://en.cppreference.com/w/cpp/memory" target="_blank" rel="external">cppreference website</a>。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p> auto_ptr和unique_ptr在复制拷贝时，资源的所有权会变更，复制之后原先的就不能使用了。但如果我想让多个智能指针同时引用同一个指针时，又该怎么办呢？shared_ptr就是为解决这个问题而生的。如其所名(shared)，大家共享一个指针，共同管理一个资源。但此时问题来了，大家都引用一个指针，那怎么知道什么时候该释放这个指针呢？c++使用一个简单的机制来解决这个问题————<strong>引用计数</strong>。每当一个新的shared_ptr指向一个指针时，就增加1，当一个shared_ptr析构时，就减1，当计数的值为0时就释放这个指针。</p>
<p> 示例代码：(代码来自<a href="http://blog.csdn.net/sndaxdrs/article/details/6175701" target="_blank" rel="external">笑对人生的blog</a>, 有更改)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));        <span class="comment">// 一个指向整数的shared_ptr</span></div><div class="line">sp.unique();                            <span class="comment">// unique() return true，现在shared_ptr是指针的唯一持有者</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp;               <span class="comment">// 第二个shared_ptr，拷贝构造函数</span></div><div class="line">sp == sp2 &amp;&amp; sp.use_count() == <span class="number">2</span>;       <span class="comment">// 此表达式为真，两个shared_ptr相等，指向同一个对象，引用计数为2</span></div><div class="line">*sp2 = <span class="number">100</span>;                             <span class="comment">// 使用解引用操作符修改被指对象</span></div><div class="line"><span class="keyword">if</span>(*sp == <span class="number">100</span>)</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp也同时被修改"</span>;</div><div class="line">sp.reset();                             <span class="comment">// 停止sp对被指对象的引用</span></div><div class="line"><span class="keyword">if</span>(!sp &amp;&amp; sp2.use_count() == <span class="number">1</span>)</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp不再持有任何指针（空指针）"</span>;</div></pre></td></tr></table></figure>
<p> shared_ptr的特性使得它可以代替原生的指针，我们可以方便的传递指针，并且不用担心资源管理的细节。在恰当的时候，基于引用计数的机制会帮我们释放指针。一切都很令人开心。就像下面例子中的使用方式。将下面代码中的所有<code>shared_ptr&lt;Foo&gt;</code>更换为<code>Foo*</code>，你会发现一切都正常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Boo &#123;</div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; foo;</div><div class="line"></div><div class="line">    Boo(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="built_in">shared_ptr</span>&lt;Foo&gt; foo)</div><div class="line">        : str(str), foo(foo) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; createFoo(<span class="keyword">int</span> val);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomethingWithFoo</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Foo&gt; foo)</span></span>;</div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;Boo&gt; func()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> foo = createFoo(<span class="number">123</span>);</div><div class="line">    doSomethingWithFoo(foo);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Boo&gt;(<span class="keyword">new</span> Boo(<span class="string">"str"</span>, foo));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p> 先让我们了解引用计数更多一点，你可能会想既然引用计数很完美，为什么java，javascript，lua需要复杂的垃圾回收机制？原因是引用计数存在<strong>循环引用</strong>的问题，考虑下面这个情景：</p>
<p> <img src="/images/引用计数-循环引用.png" alt="引用计数中的循环引用"></p>
<p> 这种情况下，foo1的引用计数是2，一旦fooListHead不再引用foo1，此时foo1的引用计数将变为1，并且造成右边环形的三个对象永远不会被释放的问题。想要在每次解除引用时侦测是否有环形成是非常麻烦的事，所以提出了<strong>weak_ptr</strong>。weak_ptr在引用对象时，不增加引用计数值（所以叫虚引用）。既然不增加计数值，那么在引用之后，被指对象可能被释放了，所以不能直接读取weak_ptr中引用的对象。在使用对象之前必须先检查所引用的对象是否已经被释放，如果没有，则需要将引用计数值加1，然后访问此对象，访问完之后，再将引用计数值减1。由此可见，使用shared_ptr需要在必要的地方用weak_ptr代替shared_ptr。这项工作需要由程序员来手工管理，所以shared_ptr只是提供了有限的垃圾回收功能。</p>
<h2 id="垃圾回收-c-java-javascript-lua"><a href="#垃圾回收-c-java-javascript-lua" class="headerlink" title="垃圾回收(c++, java, javascript, lua)"></a>垃圾回收(c++, java, javascript, lua)</h2><p> java, javascript, lua都使用复杂的垃圾回收机制来管理object，使得程序员从繁重的内存管理中解放出来。这些语言中的对象在没有地方引用它们时，在一定的时候就会被垃圾回收机制处理掉。如何跟踪这些unreachable objects，是垃圾回收的主要任务，了解<a href="http://www.memorymanagement.org/mmref/recycle.html#tracing-collectors" target="_blank" rel="external">相关的算法</a>。</p>
<h4 id="Garbage-Collection-in-c"><a href="#Garbage-Collection-in-c" class="headerlink" title="Garbage Collection in c++"></a>Garbage Collection in c++</h4><p> 设想一下，一个c++库提供垃圾回收的能力，它实现了一个object wrapper。这个object wrapper是一个类似shared_ptr的智能指针，我们暂且叫它smart_ptr。smart_ptr不使用引用计数来管理它引用的对象，它使用一个真正的垃圾回收算法。如果我们约定不在代码中传递指针和new运算符，而总是传递smart_ptr和使用new_smart_ptr函数来代替new运算符，并且new_smart_ptr总是返回一个smart_ptr，在不考虑性能的情况下，那么我们可以获得和java, javascript等语言一样的内存自动管理能力。我们永远不需要手动地编写代码来释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> smart_ptr</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span>... Args&gt;</div><div class="line">smart_ptr&lt;T&gt; new_smart_ptr(Args &amp;&amp;...args) &#123; ... &#125;</div><div class="line"></div><div class="line"></div><div class="line">smart_ptr&lt;<span class="keyword">int</span>&gt; example()</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        smart_ptr&lt;Foo&gt; foo = new_smart_ptr&lt;Foo&gt;(<span class="number">123</span>);</div><div class="line">    &#125;</div><div class="line">    smart_ptr&lt;Foo&gt; foo = new_smart_ptr&lt;Foo&gt;(<span class="number">321</span>);</div><div class="line">    str = smart_ptr_null; <span class="comment">// 使用smart_ptr_null代替nullptr</span></div><div class="line">                          <span class="comment">// 之前分配的对象将被回收掉</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 现在联系前面的一节 <em>c++中的struct/class</em> 中关于c与c++的对比，考虑一下，使用c语言能够实现上面的能力吗？</p>
<h2 id="额外链接"><a href="#额外链接" class="headerlink" title="额外链接"></a>额外链接</h2><ul>
<li><a href="www.memorymanagement.org">memorymanagement.org</a> - Resource for programmers and computer scientists interested in memory management and garbage collection.</li>
<li><a href="http://www.cplusplus.com/reference/memory" target="_blank" rel="external">cplusplus.com</a> - Memory page in cplusplus.</li>
<li><a href="http://en.cppreference.com/w/cpp/memory" target="_blank" rel="external">cppreference.com</a> - Memory page in cppreference.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; 本文面向c++初学者，讲述现代c++语言中的资源管理，包含但不限于：资源获取即初始化(RAII), 智能指针，引用计数，weak_ptr的由来，垃圾回收机制。帮助c++初学者了解c++与c在资源管理上的不同，理解c++中的struct与c中的不同之处。并与具有完备的垃圾回收机制的语言进行对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="内存管理" scheme="https://morrow1nd.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="cpp" scheme="https://morrow1nd.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Stack Allocator在递归下降分析法中的运用</title>
    <link href="https://morrow1nd.github.io/2017/01/07/Stack-Allocator%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <id>https://morrow1nd.github.io/2017/01/07/Stack-Allocator在递归下降分析法中的运用/</id>
    <published>2017-01-07T12:04:50.000Z</published>
    <updated>2017-02-14T14:08:01.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stack-Allocator"><a href="#Stack-Allocator" class="headerlink" title="Stack Allocator"></a>Stack Allocator</h2><p>Stack allocator是一种在栈上动态分配内存的内存管理机制，它能够提供和使用局部变量相近的速度，并且不用考虑内存碎片化的问题。但它有一个特点：<strong>必须按照分配内存的顺序相反地依次释放内存</strong>。由于这一特点，我们更多的只是在一个函数中使用它分配内存并在函数返回前释放掉内存。在某些需要动态分配内存的递归函数中，使用stack allocator能够极大地减少向系统请求内存的次数，从而极大地提高速度。</p>
<a id="more"></a>
<h2 id="在递归下降分析法中的应用"><a href="#在递归下降分析法中的应用" class="headerlink" title="在递归下降分析法中的应用"></a>在递归下降分析法中的应用</h2><p><a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="external">递归下降分析法</a>是一种简单直白的文法分析方法，本文不会过多的介绍它的细节，更多信息请参考下面的额外链接。递归下降分析法为每一个非终结符建立相应的子程序（函数）,然后模拟语法树自动向下推导，在推导过程中遇到终结符则检查是否匹配，遇到非终结符则调用相应的子程序（函数）接着处理。下面列举选自<a href="https://github.com/morrow1nd/luax" target="_blank" rel="external">luax</a>的部分代码来说明为什么可以在递归下降分析法中使用stack allocator。</p>
<p>文法片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">addtive_expr -&gt; </div><div class="line">          multiply_expr addtive_op addtive_expr</div><div class="line">        | multiply_expr</div><div class="line"></div><div class="line">multiply_expr -&gt;</div><div class="line">          prefix_expr multiply_op multiply_expr</div><div class="line">        | prefix_expr</div><div class="line"></div><div class="line">addtive_op -&gt;</div><div class="line">          &apos;+&apos;</div><div class="line">        | &apos;-&apos;</div><div class="line"></div><div class="line">multiply_op -&gt;</div><div class="line">          &apos;*&apos;</div><div class="line">        | &apos;/&apos;</div></pre></td></tr></table></figure></p>
<p>递归下降分析:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 非终结符</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">addtive_expr</span><span class="params">(parser *p, syntax_node *self)</span></span></div><div class="line">&#123;</div><div class="line">    NEW_SYNTAX_NODE(multiply_expr_node);</div><div class="line">    <span class="keyword">if</span> (multiply_expr(p, multiply_expr_node) == <span class="number">0</span>) &#123;</div><div class="line">        NEW_SYNTAX_NODE(addtive_op_node);</div><div class="line">        <span class="keyword">int</span> backup_state = lx_token_scanner_get_curr_state(p-&gt;scanner);</div><div class="line">        <span class="keyword">if</span> (addtive_op(p, addtive_op_node) == <span class="number">0</span>) &#123;</div><div class="line">            NEW_SYNTAX_NODE(addtive_expr_node);</div><div class="line">            <span class="keyword">if</span> (addtive_expr(p, addtive_expr_node) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 调用 addtive_expr -&gt; multiply_expr addtive_op addtive_expr 规则对应的回调函数</span></div><div class="line">                callback__addtive_expr__multiply_expr__addtive_op__addtive_expr(</div><div class="line">                    self, multiply_expr_node, addtive_op_node, addtive_expr_node);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 推导成功</span></div><div class="line">            &#125;</div><div class="line">            FREE_SYNTAX_NODE(addtive_expr_node);</div><div class="line">        &#125;</div><div class="line">        lx_token_scanner_recover_state(p-&gt;scanner, backup_state);</div><div class="line">        FREE_SYNTAX_NODE(addtive_op_node);</div><div class="line">        <span class="comment">// 调用 addtive_expr -&gt; multiply_expr 规则对应的回调函数</span></div><div class="line">        call_back_addtive_expr__multiply_expr(self, multiply_expr_node);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 推导成功</span></div><div class="line">    &#125;</div><div class="line">    FREE_SYNTAX_NODE(multiply_expr_node);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 推导失败，说明不是addtive_expr</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 相应的回调函数</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback__addtive_expr__multiply_expr__addtive_op__addtive_expr</span><span class="params">(par _self, par _1, par _2, par _3)</span></span></div><div class="line">&#123;</div><div class="line">    debuglog(<span class="string">"addtive_expr  -&gt;  multiply_expr addtive_op addtive_expr"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_back_addtive_expr__multiply_expr</span><span class="params">(par _self, par _1)</span></span></div><div class="line">&#123;</div><div class="line">    debuglog(<span class="string">"addtive_expr  -&gt;  multiply_expr"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，在推导失败之前，会依次释放掉之前分配的内存，即此时stack alocator中的栈恢复到调用addtive_expr之前的状态。如果推导成功，则栈中只会存留推导成功的节点，这些节点将在之后无用时统一释放。如此这般，我们就能满足stack allocator的要求。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>luax在语法分析器中使用了stack allocator，下面使用它进行测试。测试数据是90行luax代码，包含了基本的表达式语句及复杂的函数定义、if语句、while语句。下面分别对使用了stack allocator的程序和未使用stack allocator的程序运行测试。</p>
<p>耗时测试：</p>
<ul>
<li>using_stack_malloc.exe  <ul>
<li>831us 1056us 987us 821us 1024us 1003us 672us 797us 755us 517us 最大值：1056us 最小值：517us 平均值：846us</li>
</ul>
</li>
<li>using_normal_malloc.exe <ul>
<li>2794us 3182us 3128us 2843us 2709us 2267us 3250us 2677us 3489us 2257us  最大值：3489us 最小值：2257us 平均值：2859us</li>
</ul>
</li>
</ul>
<p>速度提高3.3倍</p>
<p>malloc调用次数：</p>
<ul>
<li>using_stack_malloc.exe 376 </li>
<li>using_normal_malloc.exe 5500</li>
</ul>
<h2 id="Stack-Allocator实现"><a href="#Stack-Allocator实现" class="headerlink" title="Stack Allocator实现"></a>Stack Allocator实现</h2><p>接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个stack allocator</span></div><div class="line"><span class="function">lx_stack_allocator* <span class="title">lx_stack_allocator_create</span><span class="params">(<span class="keyword">size_t</span> block_capacity)</span></span>;</div><div class="line"><span class="comment">// 销毁一个stack allocator</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lx_stack_allocator_delete</span><span class="params">(lx_stack_allocator *sallocator)</span></span>;</div><div class="line"><span class="comment">// 使用给定的stack allocator分配内存</span></div><div class="line"><span class="function"><span class="keyword">void</span> * <span class="title">lx_stack_allocator_alloc</span><span class="params">(lx_stack_allocator *sallocator, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="comment">// 在给定的stack_allocator中释放内存</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lx_stack_allocator_free</span><span class="params">(lx_stack_allocator *sallocator, <span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>程序具有栈空间(stack)和堆空间(heap)。从堆空间中获取内存灵活，持久，但缺点是耗时（相比于从栈中获取），而且会产生内存碎片问题。在luax中实现的stack allocator可以提供能够急速动态获取且持久的内存。Stack allocator实则维护一个位于heap中的栈，这个栈是一个由多个块(block)连接组成的链表。分配和释放操作在这个栈中进行。每当栈装满时，就会添加一个新的block。函数lx_stack_allocator_create的参数block_capacity实际上就是block的大小，所以设置一个合适的block_capacity十分重要。另外lx_stack_allocator_alloc还考虑到需要分配超过一个block的容量的情况，这时它会临时添加一个足够大的block，如果你的应用中这种情况经常发生，这说明你应该选用一个大一些的block_capacity了。</p>
<h2 id="其它：Frame-Allocator"><a href="#其它：Frame-Allocator" class="headerlink" title="其它：Frame Allocator"></a>其它：Frame Allocator</h2><p>特点：在frame中分配多次内存，一次释放这个frame</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> fallocator = frame_allocator_create();</div><div class="line">fallocator.mark(); <span class="comment">// 设置一个frame</span></div><div class="line"><span class="keyword">auto</span> a1 = fallocator.alloc(<span class="number">10</span>);</div><div class="line"><span class="keyword">auto</span> a2 = fallocator.alloc(<span class="number">13</span>);</div><div class="line">...</div><div class="line"></div><div class="line">fallocator.mark(); <span class="comment">// 设置一个frame</span></div><div class="line"><span class="keyword">auto</span> b1 = fallocator.alloc(<span class="number">9</span>);</div><div class="line"><span class="keyword">auto</span> b2 = fallocator.alloc(<span class="number">98</span>);</div><div class="line">...</div><div class="line"></div><div class="line">fallocator.clear(); <span class="comment">// 释放所有的b1, b2, b...</span></div><div class="line">fallocator.clear(); <span class="comment">// 释放所有的a1, a2, a...</span></div></pre></td></tr></table></figure>
<h2 id="额外链接"><a href="#额外链接" class="headerlink" title="额外链接"></a>额外链接</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="external">Recursive Descent Parser</a> - in wikipedia</li>
<li><a href="http://teaching.idallen.com/cst8152/98w/recursive_decent_parsing.html" target="_blank" rel="external">How to turn a Grammar into C code</a> - a brief tutorial on implementing recursive descent parser</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Stack-Allocator&quot;&gt;&lt;a href=&quot;#Stack-Allocator&quot; class=&quot;headerlink&quot; title=&quot;Stack Allocator&quot;&gt;&lt;/a&gt;Stack Allocator&lt;/h2&gt;&lt;p&gt;Stack allocator是一种在栈上动态分配内存的内存管理机制，它能够提供和使用局部变量相近的速度，并且不用考虑内存碎片化的问题。但它有一个特点：&lt;strong&gt;必须按照分配内存的顺序相反地依次释放内存&lt;/strong&gt;。由于这一特点，我们更多的只是在一个函数中使用它分配内存并在函数返回前释放掉内存。在某些需要动态分配内存的递归函数中，使用stack allocator能够极大地减少向系统请求内存的次数，从而极大地提高速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="内存管理" scheme="https://morrow1nd.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="解释器" scheme="https://morrow1nd.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://morrow1nd.github.io/2017/01/07/hello-world/"/>
    <id>https://morrow1nd.github.io/2017/01/07/hello-world/</id>
    <published>2017-01-07T10:51:37.583Z</published>
    <updated>2017-01-07T10:51:37.583Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
